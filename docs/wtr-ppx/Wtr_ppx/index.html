<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Wtr_ppx (wtr-ppx.Wtr_ppx)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 91f631096"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">wtr-ppx</a> &#x00BB; Wtr_ppx</nav><header class="odoc-preamble"><h1>Module <code><span>Wtr_ppx</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#custom-decoder">Custom Decoder</a></li></ul></nav><div class="odoc-content"><p><code>%routes &quot;&quot;</code> ppx presents an alternate and productive way of specifying a <i>route</i> value.</p><p>&lt;code class=&quot;language-html&quot;&gt; routes = <code>http-methods &quot;;&quot; </code> http-path <code>&quot;?&quot; http-query</code></p><p>http-methods = ; Note comparison are case-insensitive &quot;GET&quot; / &quot;HEAD&quot; / &quot;POST&quot; / &quot;PUT&quot; / &quot;DELETE&quot; / &quot;CONNECT&quot; / &quot;OPTIONS&quot; / &quot;TRACE&quot; / other-http-method ; Will be converted to &quot;`Method other-http-method&quot; in OCaml</p><p>other-http-method = 1*ALPHA</p><p>http-path = &quot;/&quot; wtr-segment</p><p>wtr-segment = wtr-arg / splat / wildcard / <code>segment-nz *( &quot;/&quot; segment)</code> wtr-arg = &quot;:&quot; 1( &quot;int&quot; / &quot;int32&quot; / &quot;int64&quot; / &quot;float&quot; / &quot;bool&quot; / &quot;string&quot; ) splat = &quot;**&quot; wildcard = &quot;*&quot; segment = *pchar segment-nz = 1*pchar pchar = unreserved / pct-encoded / sub-delims / &quot;:&quot; / &quot;@&quot; unreserved = ALPHA / DIGIT / &quot;-&quot; / &quot;.&quot; / &quot;_&quot; / &quot;~&quot; pct-encoded = &quot;%&quot; HEXDIG HEXDIG sub-delims = &quot;!&quot; / &quot;$&quot; / &quot;&amp;&quot; / &quot;'&quot; / &quot;(&quot; / &quot;)&quot; / &quot;*&quot; / &quot;+&quot; / &quot;,&quot; / &quot;;&quot; / &quot;=&quot;</p><p>http-query = query-key-value *(&quot;&amp;&quot; query-key-value) query-key-value = query-name &quot;=&quot; query-value query-value = 1*pchar query-name = 1( pchar / &quot;/&quot; / &quot;?&quot; ) qchar = unreserved / pct-encoded / qsub-delims / &quot;:&quot; / &quot;@&quot; qsub-delims = &quot;!&quot; / &quot;$&quot; / &quot;'&quot; / &quot;(&quot; / &quot;)&quot; / &quot;*&quot; / &quot;+&quot; / &quot;,&quot; / &quot;;&quot;</p><p>ALPHA = %x41-5A / %x61-7A ; A-Z / a-z DIGIT = %x30-39 ; 0-9 HEXDIG = DIGIT / &quot;A&quot; / &quot;B&quot; / &quot;C&quot; / &quot;D&quot; / &quot;E&quot; / &quot;F&quot; &lt;/code&gt;</p><ul><li><code>%routes</code> = <code>http methods separated by comma ; http uri</code></li><li><code>http uri = RFC3986 URI syntax for Path and Query with addition of wtr {i arg} syntax</code></li></ul><p>A request target/uri in a <code>%routes</code> ppx is syntactically and sematically a HTTP URI with the addition of <i>arg</i> components and some useful additions listed below:</p><ul><li><b>GET</b> is the default HTTP method if none is specified.</li><li><b>Full splat <code>**</code></b> - Full spat operator matches any/all path following a full splat. For example <code>/home/**</code> matches the following uri paths, <code>/home/about/, home/contact, /home/product</code> etc. Full splat must be the last component of an uri. <code>wtr</code> decodes the remaining matched uri in the route handler. For example,</li></ul><pre><code>let r =
  Wtr.t [{%routes|get; /public/** |} (fun url -&gt; Format.sprintf &quot;%s&quot; url)]
in
let s = Wtr.match' `GET &quot;/public/css/style.css&quot; in
s = Some &quot;css/style.css&quot;</code></pre><ul><li><b>Wildward <code>*</code></b> - A wildcard operator matches any text appearing on the path component position. For example, uri <code>/home/*/page1</code> matches the following <code>/home/23/page1, /home/true/page1, /home/234.4/page1</code> etc. The semantics of wildcard operator is the same as using <code>:string</code> string in a uri.</li><li><b>Trailing slash <code>/</code></b> - A trailing slash ensures that Wtr will match a trailing <code>/</code> in a uri. For example, uri <code>/home/about/</code> matches <code>/home/about/</code> but not <code>/home/about</code>.</li></ul><h3 id="custom-decoder"><a href="#custom-decoder" class="anchor"></a>Custom Decoder</h3><p>The convention for creating a custom decoder that can be used in wtr ppxes are as follows:</p><ol><li>Encapsulated in a module</li><li>The module defines a type called `t`</li><li>The module defines a value called <code>t</code> which is of type <code>t Wtr.decoder</code>.</li></ol><p>As an example, we define a custom decoder called <code>Fruit</code> and use it in wtr ppxes:</p><pre>      module Fruit = struct
        type t = Apple | Orange | Pineapple

        let t : t Wtr.decoder =
          Wtr.decoder ~name:&quot;fruit&quot; ~decode:(function
            | &quot;apple&quot; -&gt; Some Apple
            | &quot;orange&quot; -&gt; Some Orange
            | &quot;pineapple&quot; -&gt; Some Pineapple
            | _ -&gt; None )
      end</pre><p>The custom decoder thus defined can then can be used in <code>%routes</code> ppx as follows:</p><pre>[%routes &quot;get; /fruit/:Fruit&quot;] fruit_page</pre><p>Note the name following the colon <code>:</code> must match the name of the module, i.e. <code>:Fruit</code> in the above example.</p></div></body></html>